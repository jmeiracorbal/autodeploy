#!/bin/bash

# script que etiqueta de forma automática los cambios que encuentra en el repositorio remoto...
# es un cutre-sistema de integración y despliegue continuo... pero válido para según que casos

# no me ejecutes desde local :) (a menos que estemos trabajando en el propio script, ya que detectas tus propios cambios porque remote <> local)

# add your webhook url
slack_webhook=

app_name=$1
actual_date=$(date +%F)
actual_time=$(date +%F-%T)

# important, synchronize local with remote previously because $LOCAL != $REMOTE o $LOCAL = $REMOTE
git remote update >&/dev/null

# force update tags
git fetch --tags --all >&/dev/null

UPSTREAM=${1:-'@{u}'}
LOCAL=$(git rev-parse @)
REMOTE=$(git rev-parse "$UPSTREAM")
BASE=$(git merge-base @ "$UPSTREAM")

if [ $LOCAL = $REMOTE ]; then
  # its ok status: no need advice
  echo "No changes detected" >&/dev/null

elif [ $LOCAL = $BASE ]; then
  # Need to pull: for me its a best moment to tag

  # descargamos los cambios
  git pull >&/dev/null

  # obtenemos la última etiqueta creada
  last_tag=$(git tag | sort -r | head -n 1)

  # creamos una nueva etiqueta a partir de la obtenida
  new_tag=$(echo $last_tag | awk -F. -v OFS=. 'NF==1{print ++$NF}; NF>1{if(length($NF+1)>length($NF))$(NF-1)++; $NF=sprintf("%0*d", length($NF), ($NF+1)%(10^length($NF))); print}')

  # publicamos la nueva versión (publicamos sólo la creada por si hay antiguas creadas en local)
  git tag $new_tag && git push origin refs/tags/$new_tag

  # send slack message
  ./func/slack_deploy $slack_webhook $1 $new_tag

elif [ $REMOTE = $BASE ]; then

  # Need to push: for me its an error... but for you, anyone knows
  echo "${actual_time}: alguien ha realizado cambios en el servidor en producción" >&/dev/null

  # send slack message
  ./func/slack_deploy $slack_webhook $1 $new_tag

else
  # its ok status
  echo "${actual_time}: \n Diverged" >&/dev/null
fi
